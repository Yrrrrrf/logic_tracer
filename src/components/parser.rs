//! # Parser Module
//!
//! This module is responsible for parsing the `Token Stream` generated by the [`Lexer`](crate::components::lexer)
//! into an Abstract Syntax Tree (AST). It acts as the second stage in the compiler pipeline, converting a linear
//! sequence of tokens into a structured format that represents the grammatical structure of the source code.
//!
//! The AST generated is essential for subsequent stages of the compiler, such as semantic analysis and
//! generation of the intermediate representation.

// Neo grammar module note moved into formal documentation.
//! ## Neo Grammar
//!
//! Contains the grammar for the Neo language defined primarily using the `Token` types. This grammar is
//! critical for parsing as it dictates the syntactic structure of the language.

#![allow(unused)]

use crate::components::{
    lexer::*,
    tokens::*,
};

/// Represents a parser for converting a sequence of tokens into an AST.
///
/// The `Parser` holds a list of tokens and facilitates their conversion into an AST by
/// applying the grammatical rules of the language.
pub struct Parser {
    tokens: Vec<Box<dyn Token>>,
    // current: usize,
}

impl Parser {
    /// Constructs a new `Parser` instance with a given list of tokens.
    ///
    /// # Arguments
    ///
    /// * `tokens` - A vector of boxed tokens (dynamically typed) to be parsed.
    pub fn new(tokens: Vec<Box<dyn Token>>) -> Self {
        Self {
            tokens,
            // current: 0,
        }
    }

    // todo: Build the AST data structure or look for some way to represent the AST...
    // todo: AST is a type of tree that represents the structure of the source code.
    // todo: The main goal of the AST is to simplify the source code and make it easier to analyze.
    // todo: It also contains the grammar of the source code. (rules to mark the source code as valid)
    pub fn parse(&mut self) {
        // let mut ast = AST::new();
        // let mut current = 0;
        // let mut current_token = self.tokens[current];
    }

}

